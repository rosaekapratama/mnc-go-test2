// Code generated by mockery v2.46.3. DO NOT EDIT.

package repositories

import (
	context "context"

	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"

	repo "github.com/rosaekapratama/mnc-go-test2/models/repo"

	uuid "github.com/google/uuid"
)

// MockAccountRepository is an autogenerated mock type for the AccountRepository type
type MockAccountRepository struct {
	mock.Mock
}

type MockAccountRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountRepository) EXPECT() *MockAccountRepository_Expecter {
	return &MockAccountRepository_Expecter{mock: &_m.Mock}
}

// CreateSaving provides a mock function with given fields: ctx, tx, account
func (_m *MockAccountRepository) CreateSaving(ctx context.Context, tx *gorm.DB, account *repo.Account) error {
	ret := _m.Called(ctx, tx, account)

	if len(ret) == 0 {
		panic("no return value specified for CreateSaving")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, *repo.Account) error); ok {
		r0 = rf(ctx, tx, account)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAccountRepository_CreateSaving_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSaving'
type MockAccountRepository_CreateSaving_Call struct {
	*mock.Call
}

// CreateSaving is a helper method to define mock.On call
//   - ctx context.Context
//   - tx *gorm.DB
//   - account *repo.Account
func (_e *MockAccountRepository_Expecter) CreateSaving(ctx interface{}, tx interface{}, account interface{}) *MockAccountRepository_CreateSaving_Call {
	return &MockAccountRepository_CreateSaving_Call{Call: _e.mock.On("CreateSaving", ctx, tx, account)}
}

func (_c *MockAccountRepository_CreateSaving_Call) Run(run func(ctx context.Context, tx *gorm.DB, account *repo.Account)) *MockAccountRepository_CreateSaving_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*gorm.DB), args[2].(*repo.Account))
	})
	return _c
}

func (_c *MockAccountRepository_CreateSaving_Call) Return(err error) *MockAccountRepository_CreateSaving_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAccountRepository_CreateSaving_Call) RunAndReturn(run func(context.Context, *gorm.DB, *repo.Account) error) *MockAccountRepository_CreateSaving_Call {
	_c.Call.Return(run)
	return _c
}

// Credit provides a mock function with given fields: ctx, tx, accountId, amount
func (_m *MockAccountRepository) Credit(ctx context.Context, tx *gorm.DB, accountId uuid.UUID, amount float64) (*repo.Account, error) {
	ret := _m.Called(ctx, tx, accountId, amount)

	if len(ret) == 0 {
		panic("no return value specified for Credit")
	}

	var r0 *repo.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, uuid.UUID, float64) (*repo.Account, error)); ok {
		return rf(ctx, tx, accountId, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, uuid.UUID, float64) *repo.Account); ok {
		r0 = rf(ctx, tx, accountId, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*repo.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, uuid.UUID, float64) error); ok {
		r1 = rf(ctx, tx, accountId, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountRepository_Credit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Credit'
type MockAccountRepository_Credit_Call struct {
	*mock.Call
}

// Credit is a helper method to define mock.On call
//   - ctx context.Context
//   - tx *gorm.DB
//   - accountId uuid.UUID
//   - amount float64
func (_e *MockAccountRepository_Expecter) Credit(ctx interface{}, tx interface{}, accountId interface{}, amount interface{}) *MockAccountRepository_Credit_Call {
	return &MockAccountRepository_Credit_Call{Call: _e.mock.On("Credit", ctx, tx, accountId, amount)}
}

func (_c *MockAccountRepository_Credit_Call) Run(run func(ctx context.Context, tx *gorm.DB, accountId uuid.UUID, amount float64)) *MockAccountRepository_Credit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*gorm.DB), args[2].(uuid.UUID), args[3].(float64))
	})
	return _c
}

func (_c *MockAccountRepository_Credit_Call) Return(account *repo.Account, err error) *MockAccountRepository_Credit_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockAccountRepository_Credit_Call) RunAndReturn(run func(context.Context, *gorm.DB, uuid.UUID, float64) (*repo.Account, error)) *MockAccountRepository_Credit_Call {
	_c.Call.Return(run)
	return _c
}

// Debit provides a mock function with given fields: ctx, tx, accountId, amount
func (_m *MockAccountRepository) Debit(ctx context.Context, tx *gorm.DB, accountId uuid.UUID, amount float64) (*repo.Account, error) {
	ret := _m.Called(ctx, tx, accountId, amount)

	if len(ret) == 0 {
		panic("no return value specified for Debit")
	}

	var r0 *repo.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, uuid.UUID, float64) (*repo.Account, error)); ok {
		return rf(ctx, tx, accountId, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, uuid.UUID, float64) *repo.Account); ok {
		r0 = rf(ctx, tx, accountId, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*repo.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, uuid.UUID, float64) error); ok {
		r1 = rf(ctx, tx, accountId, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountRepository_Debit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debit'
type MockAccountRepository_Debit_Call struct {
	*mock.Call
}

// Debit is a helper method to define mock.On call
//   - ctx context.Context
//   - tx *gorm.DB
//   - accountId uuid.UUID
//   - amount float64
func (_e *MockAccountRepository_Expecter) Debit(ctx interface{}, tx interface{}, accountId interface{}, amount interface{}) *MockAccountRepository_Debit_Call {
	return &MockAccountRepository_Debit_Call{Call: _e.mock.On("Debit", ctx, tx, accountId, amount)}
}

func (_c *MockAccountRepository_Debit_Call) Run(run func(ctx context.Context, tx *gorm.DB, accountId uuid.UUID, amount float64)) *MockAccountRepository_Debit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*gorm.DB), args[2].(uuid.UUID), args[3].(float64))
	})
	return _c
}

func (_c *MockAccountRepository_Debit_Call) Return(account *repo.Account, err error) *MockAccountRepository_Debit_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockAccountRepository_Debit_Call) RunAndReturn(run func(context.Context, *gorm.DB, uuid.UUID, float64) (*repo.Account, error)) *MockAccountRepository_Debit_Call {
	_c.Call.Return(run)
	return _c
}

// FindById provides a mock function with given fields: ctx, accountId
func (_m *MockAccountRepository) FindById(ctx context.Context, accountId uuid.UUID) (*repo.Account, error) {
	ret := _m.Called(ctx, accountId)

	if len(ret) == 0 {
		panic("no return value specified for FindById")
	}

	var r0 *repo.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*repo.Account, error)); ok {
		return rf(ctx, accountId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *repo.Account); ok {
		r0 = rf(ctx, accountId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*repo.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, accountId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountRepository_FindById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindById'
type MockAccountRepository_FindById_Call struct {
	*mock.Call
}

// FindById is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId uuid.UUID
func (_e *MockAccountRepository_Expecter) FindById(ctx interface{}, accountId interface{}) *MockAccountRepository_FindById_Call {
	return &MockAccountRepository_FindById_Call{Call: _e.mock.On("FindById", ctx, accountId)}
}

func (_c *MockAccountRepository_FindById_Call) Run(run func(ctx context.Context, accountId uuid.UUID)) *MockAccountRepository_FindById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockAccountRepository_FindById_Call) Return(account *repo.Account, err error) *MockAccountRepository_FindById_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockAccountRepository_FindById_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*repo.Account, error)) *MockAccountRepository_FindById_Call {
	_c.Call.Return(run)
	return _c
}

// FindSavingByUserId provides a mock function with given fields: ctx, userId
func (_m *MockAccountRepository) FindSavingByUserId(ctx context.Context, userId uuid.UUID) (*repo.Account, error) {
	ret := _m.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for FindSavingByUserId")
	}

	var r0 *repo.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*repo.Account, error)); ok {
		return rf(ctx, userId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *repo.Account); ok {
		r0 = rf(ctx, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*repo.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountRepository_FindSavingByUserId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindSavingByUserId'
type MockAccountRepository_FindSavingByUserId_Call struct {
	*mock.Call
}

// FindSavingByUserId is a helper method to define mock.On call
//   - ctx context.Context
//   - userId uuid.UUID
func (_e *MockAccountRepository_Expecter) FindSavingByUserId(ctx interface{}, userId interface{}) *MockAccountRepository_FindSavingByUserId_Call {
	return &MockAccountRepository_FindSavingByUserId_Call{Call: _e.mock.On("FindSavingByUserId", ctx, userId)}
}

func (_c *MockAccountRepository_FindSavingByUserId_Call) Run(run func(ctx context.Context, userId uuid.UUID)) *MockAccountRepository_FindSavingByUserId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockAccountRepository_FindSavingByUserId_Call) Return(account *repo.Account, err error) *MockAccountRepository_FindSavingByUserId_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockAccountRepository_FindSavingByUserId_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*repo.Account, error)) *MockAccountRepository_FindSavingByUserId_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccountRepository creates a new instance of MockAccountRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountRepository {
	mock := &MockAccountRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
